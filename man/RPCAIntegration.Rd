% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/integration5.R
\name{RPCAIntegration}
\alias{RPCAIntegration}
\title{Seurat-RPCA Integration}
\usage{
RPCAIntegration(
  object = NULL,
  assay = NULL,
  layers = NULL,
  orig = NULL,
  new.reduction = "integrated.dr",
  reference = NULL,
  features = NULL,
  normalization.method = c("LogNormalize", "SCT"),
  dims = 1:30,
  k.filter = NA,
  scale.layer = "scale.data",
  groups = NULL,
  dims.to.integrate = NULL,
  k.weight = 100,
  weight.reduction = NULL,
  sd.weight = 1,
  sample.tree = NULL,
  preserve.order = FALSE,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{assay}{A vector of assay names specifying which assay to use when
constructing anchors. If NULL, the current default assay for each object is
used.}

\item{reference}{A vector specifying the object/s to be used as a reference
during integration. If NULL (default), all pairwise anchors are found (no
reference/s). If not NULL, the corresponding objects in \code{object.list}
will be used as references. When using a set of specified references, anchors
are first found between each query and each reference. The references are
then integrated through pairwise integration. Each query is then mapped to
the integrated reference.}

\item{normalization.method}{Name of normalization method used: LogNormalize
or SCT}

\item{dims}{Which dimensions to use from the CCA to specify the neighbor
search space}

\item{k.filter}{How many neighbors (k) to use when filtering anchors}

\item{dims.to.integrate}{Number of dimensions to return integrated values for}

\item{k.weight}{Number of neighbors to consider when weighting anchors}

\item{weight.reduction}{Dimension reduction to use when calculating anchor
weights. This can be one of:
\itemize{
   \item{A string, specifying the name of a dimension reduction present in
   all objects to be integrated}
   \item{A vector of strings, specifying the name of a dimension reduction to
   use for each object to be integrated}
   \item{A vector of \code{\link{DimReduc}} objects, specifying the object to
   use for each object in the integration}
   \item{NULL, in which case the full corrected space is used for computing
   anchor weights.}
}}

\item{sd.weight}{Controls the bandwidth of the Gaussian kernel for weighting}

\item{sample.tree}{Specify the order of integration. Order of integration
should be encoded in a matrix, where each row represents one of the pairwise
integration steps. Negative numbers specify a dataset, positive numbers
specify the integration results from a given row (the format of the merge
matrix included in the \code{\link{hclust}} function output). For example:
\code{matrix(c(-2, 1, -3, -1), ncol = 2)} gives:

\if{html}{\out{<div class="sourceCode">}}\preformatted{            [,1]  [,2]
       [1,]   -2   -3
       [2,]    1   -1
}\if{html}{\out{</div>}}

Which would cause dataset 2 and 3 to be integrated first, then the resulting
object integrated with dataset 1.

If NULL, the sample tree will be computed automatically.}

\item{preserve.order}{Do not reorder objects based on size for each pairwise
integration.}

\item{verbose}{Print progress bars and output}

\item{...}{Arguments passed on to \code{FindIntegrationAnchors}}
}
\description{
Seurat-RPCA Integration
}
\examples{
\dontrun{
# Preprocessing
obj <- SeuratData::LoadData("pbmcsca")
obj[["RNA"]] <- split(obj[["RNA"]], f = obj$Method)
obj <- NormalizeData(obj)
obj <- FindVariableFeatures(obj)
obj <- ScaleData(obj)
obj <- RunPCA(obj)

# After preprocessing, we run integration
obj <- IntegrateLayers(object = obj, method = RPCAIntegration, 
  orig.reduction = "pca", new.reduction = 'integrated.rpca', 
  verbose = FALSE)
  
# Reference-based Integration
# Here, we use the first layer as a reference for integraion
# Thus, we only identify anchors between the reference and the rest of the datasets, saving computational resources
obj <- IntegrateLayers(object = obj, method = RPCAIntegration, 
  orig.reduction = "pca", new.reduction = 'integrated.rpca', 
  reference = 1, verbose = FALSE)

# Modifying parameters
# We can also specify parameters such as `k.anchor` to increase the strength of integration 
obj <- IntegrateLayers(object = obj, method = RPCAIntegration, 
  orig.reduction = "pca", new.reduction = 'integrated.rpca', 
  k.anchor = 20, verbose = FALSE)

# Integrating SCTransformed data
obj <- SCTransform(object = obj)
obj <- IntegrateLayers(object = obj, method = RPCAIntegration, 
  orig.reduction = "pca", new.reduction = 'integrated.rpca', 
  assay = "SCT", verbose = FALSE)
}
  
}
